## JavaScript

### JavaScript中如何检测一个变量是一个String类型？请写出函数实现

```
typeof(str) === "string"
typeof str === "string"
str.constructor === String
```

### 比较typeof与instanceof

```
相同点：JavaScript 中 typeof 和 instanceof 常用来判断一个变量是否为空，或者是什么类型的。

typeof的定义和用法：返回值是一个字符串，用来说明变量的数据类型。

细节：
    (1)、typeof 一般只能返回如下几个结果：number,boolean,string,function,object,undefined。

    (2)、typeof 也可以用来获取一个变量是否存在，如 if(typeof a!=="undefined"){alert("ok")}，而不要去使用 if(a) 因为如果 a 不存在（未声明）则会出错。

    (3)、对于 Array,Null 等特殊对象使用 typeof 一律返回 object，这正是 typeof 的局限性。

Instanceof定义和用法：instanceof 用于判断一个变量是否属于某个对象的实例。
```

### 请你谈谈Cookie的优点与弊端

```
优点： 极高的扩展性和可用性
1) 数据持久性。

2) 不需要任何服务器资源。 Cookie 存储在客户端并在发送后由服务器读取。

3) 可配置到期规则。 控制 cookie 的生命期，使之不会永远有效。偷盗者很可能拿到一个过期的 cookie 。

4) 简单性。 基于文本的轻量结构。

5) 通过良好的编程，控制保存在 cookie 中的 session 对象的大小。

6) 通过加密和安全传输技术（ SSL ），减少 cookie 被破解的可能性。

7) 只在 cookie 中存放不敏感数据，即使被盗也不会有重大损失。

缺点：
1) Cookie 数量和长度的限制 。

    数量：每个域的 cookie 总数有限。

    a) IE6 或更低版本最多 20 个 cookie

    b) IE7 和之后的版本最后可以有 50 个 cookie

    c) Firefox 最多 50 个 cookie

    d) chrome 和 Safari 没有做硬性限制

    长度：每个 cookie 长度不超过 4KB （ 4096B ），否则会被截掉。

2) 潜在的安全风险 。 Cookie 可能被拦截、篡改。如果 cookie 被拦截，就有可能取得所有的 session 信息。

3) 用户配置为禁用 。有些用户禁用了浏览器或客户端设备接受 cookie 的能力，因此限制了这一功能。

4) 有些状态不可能保存在客户端 。例如，为了防止重复提交表单，我们需要在服务器端保存一个计数器。如果我们把这个计数器保存在客户端，那么它起不到任何作用。
```

### 以下哪些表达式的结果为true（）(多选)

  #### A.undefined == null
  #### B.isNaN("100")
  #### C.parseInt("1a") === 1
  #### D.[] instanceof Array

```
答案：A C D
A.undefined派生自null，所以在不全等的情况下，是相等的
b.isNaN()函数用来判断一个数是否是NaN,当该值是NaN或者能被转换为NaN的时候才返回true 
c.parseInt(string,raix)函数有两个参数,parseInt(string)只会被解析从第一个字符开始直到不是数字的字符部分,因此c正确。补充：parseInt()函数的第二个参数指的是进制
d.[]是Array的子集
```

### 以下哪些正则表达式满足regexp.test('abc') === true？

#### A./^abc$/

#### B./...(?=.)/

#### C./[ab]{2}\[^defgh]/

  #### D./[defgh]*/

```
A.这算是完全匹配了，^a表示以a开头，c$表示以c结尾，中间再夹个b
B."."表示匹配除换行符的任意字符，"x(?=y)"匹配'x'仅仅当'x'后面跟着'y'.这种叫做先行断言。所以这里可以理解为：
   1.当没有换行符时，只要字符前面是三的倍数/.../，并且后面跟有字符/(?=.)/，就可匹配，如1234，abcdefg,234wewrwwr（下划线处为匹配项）
   2.有换行符时，每一行要重新匹配，即字符长度独立，从0开始
C.[ab]表示a或b {2}表示长度为2  [^defgh]表示非defgh的字符，所以可匹配的有,aac,bbc,abc,abcd等，注意这里匹配长度为3
D."*"表示0或者多个字符，这里可匹配空，或者括号内任意字符
```

### 列举几条 JavaScript 的基本代码规范

```
（1）不要在同一行声明多个变量
（2）如果你不知道数组的长度，使用 push
（3）请使用 ===/!== 来比较 true/false 或者数值
（4）对字符串使用单引号 ''(因为大多时候我们的字符串。特别html会出现")
（5）使用对象字面量替代 new Array 这种形式
（6）绝对不要在一个非函数块里声明一个函数，把那个函数赋给一个变量。浏览器允许你这么做，但是它们解析不同
（7）不要使用全局函数
（8）总是使用 var 来声明变量，如果不这么做将导致产生全局变量，我们要避免污染全局命名空间
（9）Switch 语句必须带有 default 分支
（10）使用 /**...*/ 进行多行注释，包括描述，指定类型以及参数值和返回值
（11）函数不应该有时候有返回值，有时候没有返回值
（12）语句结束一定要加分号
（13）for 循环必须使用大括号
（14）if 语句必须使用大括号
（15）for-in 循环中的变量应该使用 var 关键字明确限定作用域，从而避免作用域污染
（16）避免单个字符名，让你的变量名有描述意义
（17）当命名对象、函数和实例时使用驼峰命名规则
（18）给对象原型分配方法，而不是用一个新的对象覆盖原型，覆盖原型会使继承出现问题
（19）当给事件附加数据时，传入一个哈希而不是原始值，这可以让后面的贡献者加入更多数据到事件数据里，而不用找出并更新那个事件的事件处理器
```

### ["1","2","3"].map(parseInt) 的答案是多少？

```
[1,NaN,NaN]
因为 parseInt 需要两个参数(val,radix)，其中 radix 表示解析时用的基数。
map 传了3个(element,index,array)，对应的 radix 不合法导致解析失败。
```

### new 操作符具体干了什么呢

```
(1)创建一个空对象，并且 this 变量引用该对象，同时还继承了该函数的原型。
(2)属性和方法被加入到 this 引用的对象中。
(3)新创建的对象由 this 所引用，并且最后隐式的返回 this 。
```

### document.write 和 innerHTML 有何区别？

```
document.write 只能重绘整个页面innerHTML 可以重绘页面的一部分
```

### DOM 操作——怎样添加、移除、移动、复制、创建和查找节点

```
(1)创建新节点
  createDocumentFragment() //创建一个DOM片段
  createElement() //创建一个具体的元素
  createTextNode() //创建一个文本节点
(2)添加、移除、替换、插入
  appendChild()
  removeChild()
  replaceChild()
  insertBefore() //在已有的子节点前插入一个新的子节点
(3)查找
  getElementsByTagName() //通过标签名称
  getElementsByName() //通过元素的Name属性的值(IE容错能力较强，会得到一个数组，其中包括id等于name值的)
  getElementById() //通过元素Id，唯一性
```

### HTTP协议的状态消息都有哪些?(如200、302对应的描述)

```
协议是指计算机通信网络中两台计算机之间进行通信所必须共同遵守的规定或规则，超文本传输协议(HTTP)是一种通信协议，它允许将超文本标记语言(HTML)文档从Web服务器传送到客户端的浏览器，
• “100″ : Continue（继续） 初始的请求已经接受，客户应当继续发送请求的其余部分。（HTTP 1.1新）
•  “101″ : Switching Protocols（切换协议） 请求者已要求服务器切换协议，服务器已确认并准备进行切换。（HTTP 1.1新）
•  “200″ : OK（成功） 一切正常，对GET和POST请求的应答文档跟在后面。
•  “201″ : Created（已创建）服务器已经创建了文档，Location头给出了它的URL。
•  “202″ : Accepted（已接受）服务器已接受了请求，但尚未对其进行处理。
•  “203″ : Non-Authoritative Information（非授权信息） 文档已经正常地返回，但一些应答头可能不正确，可能来自另一来源 。（HTTP 1.1新）。
•  “204″ : No Content（无内容）未返回任何内容，浏览器应该继续显示原来的文档。
•  “205″ : Reset Content（重置内容）没有新的内容，但浏览器应该重置它所显示的内容。用来强制浏览器清除表单输入内容（HTTP 1.1新）。
•  “206″ : Partial Content（部分内容）服务器成功处理了部分 GET 请求。（HTTP 1.1新）
•  “300″ : Multiple Choices（多种选择）客户请求的文档可以在多个位置找到，这些位置已经在返回的文档内列出。如果服务器要提出优先选择，则应该在Location应答头指明。
•  “301″ : Moved Permanently（永久移动）请求的网页已被永久移动到新位置。服务器返回此响应（作为对 GET 或 HEAD 请求的响应）时，会自动将请求者转到新位置。
•  “302″ : Found（临时移动）类似于301，但新的URL应该被视为临时性的替代，而不是永久性的。注意，在HTTP1.0中对应的状态信息是“Moved Temporatily”，出现该状态代码时，浏览器能够自动访问新的URL，因此它是一个很有用的状态代码。注意这个状态代码有时候可以和301替换使用。例如，如果浏览器错误地请求http://host/~user（缺少了后面的斜杠），有的服务器返回301，有的则返回302。严格地说，我们只能假定只有当原来的请求是GET时浏览器才会自动重定向。请参见307。
•  “303″ : See Other（查看其他位置）类似于301/302，不同之处在于，如果原来的请求是POST，Location头指定的重定向目标文档应该通过GET提取（HTTP 1.1新）。
•  “304″ : Not Modified（未修改）自从上次请求后，请求的网页未被修改过。原来缓冲的文档还可以继续使用，不会返回网页内容。
•  “305″ : Use Proxy（使用代理）只能使用代理访问请求的网页。如果服务器返回此响应，那么，服务器还会指明请求者应当使用的代理。（HTTP 1.1新）
•  “307″ : Temporary Redirect（临时重定向）和 302（Found）相同。许多浏览器会错误地响应302应答进行重定向，即使原来的请求是POST，即使它实际上只能在POST请求的应答是303时才能重定向。由于这个原因，HTTP 1.1新增了307，以便更加清除地区分几个状态代码：当出现303应答时，浏览器可以跟随重定向的GET和POST请求；如果是307应答，则浏览器只能跟随对GET请求的重定向。（HTTP 1.1新）
•  “400″ : Bad Request（错误请求）请求出现语法错误。
•  “401″ : Unauthorized（未授权）客户试图未经授权访问受密码保护的页面。应答中会包含一个WWW-Authenticate头，浏览器据此显示用户名字/密码对话框，然后在填写合适的Authorization头后再次发出请求。
•  “403″ : Forbidden（已禁止） 资源不可用。服务器理解客户的请求，但拒绝处理它。通常由于服务器上文件或目录的权限设置导致。
•  “404″ : Not Found（未找到）无法找到指定位置的资源。
•  “405″ : Method Not Allowed（方法禁用）请求方法（GET、POST、HEAD、DELETE、PUT、TRACE等）禁用。（HTTP 1.1新）
•  “406″ : Not Acceptable（不接受）指定的资源已经找到，但它的MIME类型和客户在Accpet头中所指定的不兼容（HTTP 1.1新）。
•  “407″ : Proxy Authentication Required（需要代理授权）类似于401，表示客户必须先经过代理服务器的授权。（HTTP 1.1新）
•  “408″ : Request Time-out（请求超时）服务器等候请求时超时。（HTTP 1.1新）
•  “409″ : Conflict（冲突）通常和PUT请求有关。由于请求和资源的当前状态相冲突，因此请求不能成功。（HTTP 1.1新）
•  “410″ : Gone（已删除）如果请求的资源已被永久删除，那么，服务器会返回此响应。该代码与 404（未找到）代码类似，但在资源以前有但现在已经不复存在的情况下，有时会替代 404 代码出现。如果资源已被永久删除，那么，您应当使用 301 代码指定该资源的新位置。（HTTP 1.1新）
•  “411″ : Length Required（需要有效长度）不会接受包含无效内容长度标头字段的请求。（HTTP 1.1新）
•  “412″ : Precondition Failed（未满足前提条件）服务器未满足请求者在请求中设置的其中一个前提条件。（HTTP 1.1新）
•  “413″ : Request Entity Too Large（请求实体过大）请求实体过大，已超出服务器的处理能力。如果服务器认为自己能够稍后再处理该请求，则应该提供一个Retry-After头。（HTTP 1.1新）
•  “414″ : Request-URI Too Large（请求的 URI 过长）请求的 URI（通常为网址）过长，服务器无法进行处理。
•  “415″ : Unsupported Media Type（不支持的媒体类型）请求的格式不受请求页面的支持。
•  “416″ : Requested range not satisfiable（请求范围不符合要求）服务器不能满足客户在请求中指定的Range头。（HTTP 1.1新）
•  “417″ : Expectation Failed（未满足期望值）服务器未满足”期望”请求标头字段的要求。
•  “500″ : Internal Server Error（服务器内部错误）服务器遇到错误，无法完成请求。
•  “501″ : Not Implemented（尚未实施） 服务器不具备完成请求的功能。例如，当服务器无法识别请求方法时，服务器可能会返回此代码。
•  “502″ : Bad Gateway（错误网关）服务器作为网关或者代理时，为了完成请求访问下一个服务器，但该服务器返回了非法的应答。
•  “503″ : Service Unavailable（服务不可用）服务器由于维护或者负载过重未能应答。通常，这只是一种暂时的状态。
•  “504″ : Gateway Time-out（网关超时） 由作为代理或网关的服务器使用，表示不能及时地从远程服务器获得应答。（HTTP 1.1新）
•  “505″ : HTTP Version not supported（HTTP 版本不受支持）不支持请求中所使用的 HTTP 协议版本。
```

### 前端开发有哪些优化方法

```
1)减少http请求次数：cssspirit,data uri
2)JS，CSS源码压缩
3)前端模板JS+数据，减少由于HTML标签导致的带宽浪费，前端用变量保存AJAX请求结果，每次操作本地变量，不用请求，减少请求次数
4)用innerHTML代替DOM操作，减少DOM操作次数，优化javascript性能
5)用setTimeout来避免页面失去响应
6)用hash-table来优化查找
7)当需要设置的样式很多时设置className而不是直接操作style
8)少用全局变量
9)缓存DOM节点查找的结果
10)避免使用CSS Expression
11)图片预载
12)避免在页面的主体布局中使用table，table要等其中的内容完全下载之后才会显示出来，显示比div+css布局慢
```

### 请你谈一谈你是如何理解前端模块化的

```
将一个复杂的程序依据一定的规则（规范）封装成几个块（文件）并进行组合。模块的内部数据的实现是私有的，只是向外部暴露一些接口（方法）与外部其他模块通信。这则就是模块化。模块化可以降低代码耦合度，减少重复代码，提高代码重用性，并且在项目结构上更加清晰，便于维护。
```

### 简单的实现一个promise

```javascript
function NewPromise(fn){
        this.state = 'PENDING'
        this.fulfillList = []
        this.rejectList = []
        fn(this.resolve.bind(this),this.reject.bind(this))
    }
    //成功，执行成功队列的函数
    NewPromise.prototype.resolve = function(data){
        this.state = 'FULFILLED'
        var args = [].slice.call(arguments)
        setTimeout(function () {
            this.fulfillList.forEach(function (itemFn,key,arr) {
                itemFn.apply(null,args)
                arr.shift()
            })
        }.bind(this),0)
    }
    //失败，执行失败队列的函数
    NewPromise.prototype.reject = function(data){
        this.state = 'REJECTED'
        var args2 = [].slice.call(arguments)
        setTimeout(function () {
            this.rejectList.forEach(function (itemFn,key,arr) {
                itemFn.apply(null,args2)
                arr.shift()
            })
        }.bind(this),0)
    }
    //成功回调函数
    NewPromise.prototype.done = function(handle){
        if(typeof handle === 'function')
            this.fulfillList.push(handle)
        else
            throw new Error('回调函数出错')
        return this
    }
    //失败回调函数
    NewPromise.prototype.fail = function(handle){
        if(typeof handle === 'function')
            this.rejectList.push(handle)
        else
            throw new Error('回调函数出错')
        return this
    }
    //失败成功写在一个方法内
    NewPromise.prototype.then = function(fulfill,reject){
        this.done(fulfill)||function () {}
            .fail(reject)||function () {}
        return this
    }
    //失败成功都执行一个函数
    NewPromise.prototype.always = function(handle){
        this.done(handle)||function () {}
            .fail(handle)||function () {}
        return this
    }
 
    var prm = new NewPromise(function (resolve,reject) {
        setTimeout(function(){
            resolve('成功的参数')
            reject('失败的参数')
        },1000)
    })
    prm.then(function(data){
        console.log(data)
    }).fail(function(data){
        console.log(data)
    })
```

### 箭头函数中this指向

```
箭头函数没有自己的this，它的this不是调用的时候决定的，是在定义的时候处在的对象就是它的this
```

### javascript继承的 6 种方法

```
1. 原型链继承
2. 借用构造函数继承
3. 组合继承(原型+借用构造)
4. 原型式继承
5. 寄生式继承
6. 寄生组合式继承
```

### 描述 GET 和 POST 的区别

```
1.get是从服务器上获取数据 post是向服务器传送数据 
2.get是把参数数据队列加到提交表单的ACTION属性所指的URL中 值和表单内各个字段一一对应 在URL中可以看到 post是通过HTTP post机制 将表单内各个字段与其内容放置在HTML HEADER内一起传送到ACTION属性所指的URL地址 用户看不到这个过程 
3.对于get方式 服务器端用Request.QueryString获取变量的值 对于post方式 服务器端用Request.Form获取提交的数据 
4.get传送的数据量较小 不能大于2KB post传送的数据量较大 一般被默认为不受限制 但理论上 IIS4中最大量为80KB IIS5中为100KB 5 get安全性非常低 post安全性较高 但是执行效率却比Post方法好
```

### 详细说明session和cookie，并指出二者的区别和适用方向。

```
cookie 和session 的区别：

1、cookie数据存放在客户的浏览器上，session数据放在服务器上。

2、cookie不是很安全，别人可以分析存放在本地的COOKIE并进行COOKIE欺骗
   考虑到安全应当使用session。

3、session会在一定时间内保存在服务器上。当访问增多，会比较占用你服务器的性能
   考虑到减轻服务器性能方面，应当使用COOKIE。

4、单个cookie保存的数据不能超过4K，很多浏览器都限制一个站点最多保存20个cookie。
```

### 用javascript实现控制一个文本框的输入字数限制，超出字数限制文本框飘红显示。

```
var oinput1 = document.getElementById("input1");
    oinput1.oninput= function(){
        var text = oinput1.value;
        if(text.length>5){
            alert("只能输入5个字符");
            oinput1.style.borderColor = "red";
        }
    }	
```

### 用js实现如下功能，将给定的数字转化成千分位的格式，如把“10000”转化成“10,000”，并考虑到性能方面的因素

```javascript
var n = 1233456;
var result;
result = change(n);
console.log(result);
function change(){
 var str=n.toString();
 var tmp="";
 while(str.length>3){
 tmp=","+str.slice(-3)+tmp;
 str=str.slice(0,str.length-3)
 }
 result = str+tmp;
 return result;
};
```

### 请你讲一下，使用setTimeout()方法来模拟setInterval()与直接使用setInterval()有什么区别

```javascript
function write(){
    setTimeout(function(){
    console.log('11');
    write();
    },1000)
}
setTimeout(write,1000)
```

### 如何实现浏览器内多个标签页之间的通信?

```
调用 localstorge、cookies 等本地存储方式
```

### js有几种数据类型，其中基本数据类型有哪些

```
五种基本类型: Undefined、Null、Boolean、Number和String。

1中复杂的数据类型————Object，Object本质上是由一组无序的名值对组成的。

Object、Array和Function则属于引用类型
```

### http 和 https 有何区别？如何灵活使用？

```
http是HTTP协议运行在TCP之上。所有传输的内容都是明文，客户端和服务器端都无法验证对方的身份。

https是HTTP运行在SSL/TLS之上，SSL/TLS运行在TCP之上。所有传输的内容都经过加密，加密采用对称加密，但对称加密的密钥用服务器方的证书进行了非对称加密。此外客户端可以验证服务器端的身份，如果配置了客户端验证，服务器方也可以验证客户端的身份
```

### jQuery获取的dom对象和原生的dom对象有何区别

```
js原生获取的dom是一个对象，jQuery对象就是一个数组对象，其实就是选择出来的元素的数组集合，所以说他们两者是不同的对象类型不等价。
```

### promise 放在try catch里面有什么结果

```
1. Promise 对象的错误具有冒泡性质,会一直向后传递,直到被捕获为止,也即是说,错误总会被下一个catch语句捕获
2. 当Promise链中抛出一个错误时,错误信息沿着链路向后传递,直至被捕获
```

### js 自定义事件实现的方法

```
1. createEvent,设置事件类型,是 html 事件还是 鼠标事件
2. initEvent 初始化事件,事件名称,是否允许冒泡,是否阻止自定义事件
3. dispatchEvent 触发事件
```

### 线程与进程的区别

```
线程的划分尺度小于进程，使得多线程程序的并发性高。 
另外，进程在执行过程中拥有独立的内存单元，而多个线程共享内存，从而极大地提高了程序的运行效率。 
线程在执行过程中与进程还是有区别的。每个独立的线程有一个程序运行的入口、顺序执行序列和程序的出口。但是线程不能够独立执行，必须依存在应用程序中，由应用程序提供多个线程执行控制。 
从逻辑角度来看，多线程的意义在于一个应用程序中，有多个执行部分可以同时执行。但操作系统并没有将多个线程看做多个独立的应用，来实现进程的调度和管理以及资源分配。这就是进程和线程的重要区别。
```

### JS有几种引入方式

```
1、行内式 直接在标签中写js代码 
2、内嵌式 可以有多个script标签，从上到下 
3、外联式 直接导入script标签，相对路径 
4、导入式 import
```

### 常见的undefined的情况

```
1.当获取对象属性名对应的属性值时如果属性名不存在，那么返回值是undefined； 
2.函数的形参如果没有实参赋 
值，在函数中默认存储undefined 
3.如果函数没有return，那么函数的返回值是undefined； 
4.如果变量只声明，没有赋值，那么默认存储也是undefined；
```

### for…in..和for…of..的区别？

```
for in 遍历循环对象
同时for in也可以遍历数组，但是会出现以下问题 
1、index索引为字符串型数字，不能直接进行几何运算 
2、遍历顺序有可能不是按照实际数组的内部顺序 
3、使用for in会遍历数组所有的可枚举属性，包括原型。
for in遍历的是数组的索引（即键名），而for of遍历的是数组元素值。
for of 遍历循环数组
for of遍历的只是数组内的元素，而不包括数组的原型属性method和索引name
```

### **什么是window对象? 什么是document对象?**

```
window对象代表浏览器中打开的一个窗口。document对象代表整个html文档。实际上，document对象是window对象的一个属性。
```

### **同步和异步的区别?**

```
同步的概念在操作系统中：不同进程协同完成某项工作而先后次序调整（通过阻塞、唤醒等方式），同步强调的是顺序性，谁先谁后。异步不存在顺序性。
同步：浏览器访问服务器，用户看到页面刷新，重新发请求，等请求完，页面刷新，新内容出现，用户看到新内容之后进行下一步操作。
异步：浏览器访问服务器请求，用户正常操作，浏览器在后端进行请求。等请求完，页面不刷新，新内容也会出现，用户看到新内容。
```

### **模块化开发怎么做？**

```
模块化开发指的是在解决某一个复杂问题或者一系列问题时，依照一种分类的思维把问题进行系统性的分解。模块化是一种将复杂系统分解为代码结构更合理，可维护性更高的可管理的模块方式。对于软件行业：系统被分解为一组高内聚，低耦合的模块。
（1）定义封装的模块
（2）定义新模块对其他模块的依赖
（3）可对其他模块的引入支持。在JavaScript中出现了一些非传统模块开发方式的规范。 CommonJS的模块规范，AMD（Asynchronous Module Definition），CMD（Common Module Definition）等。AMD是异步模块定义，所有的模块将被异步加载，模块加载不影响后边语句运行。
```

### **什么是Cookie 隔离？**

```
通过使用多个非主要域名来请求静态文件，如果静态文件都放在主域名下，那静态文件请求的时候带有的cookie的数据提交给server是非常浪费的，还不如隔离开。因为cookie有域的限制，因此不能跨域提交请求，故使用非主要域名的时候，请求头中就不会带有cookie数据，这样可以降低请求头的大小，降低请求时间，从而达到降低整体请求延时的目的。同时这种方式不会将cookie传入server，也减少了server对cookie的处理分析环节，提高了server的http请求的解析速度。
```

### **XML与JSON的区别？**

```
1) 数据体积方面。JSON相对于XML来讲，数据的体积小，传递的速度更快些。
2) 数据交互方面。JSON与JavaScript的交互更加方便，更容易解析处理，更好的数据交互。
3) 数据描述方面。JSON对数据的描述性比XML较差。
4) 传输速度方面。JSON的速度要远远快于XML。
```

### **JS垃圾回收机制？**

```
1) 标记清除：
这个算法把“对象是否不再需要”简化定义为“对象是否可以获得”。
这个算法假定设置一个叫做根（root）的对象（在Javascript里，根是全局对象）。定期的，垃圾回收器将从根开始，找所有从根开始引用的对象，然后找这些对象引用的对象。从根开始，垃圾回收器将找到所有可以获得的对象和所有不能获得的对象。

2) 引用计数：
这是最简单的垃圾收集算法。此算法把“对象是否不再需要”简化定义为“对象有没有其他对象引用到它”。如果没有引用指向该对象（零引用），对象将被垃圾回收机制回收。
该算法有个限制：无法处理循环引用。两个对象被创建，并互相引用，形成了一个循环。它们被调用之后不会离开函数作用域，所以它们已经没有用了，可以被回收了。然而，引用计数算法考虑到它们互相都有至少一次引用，所以它们不会被回收。
```

### **如何删除一个cookie？**

```
1） 将cookie的失效时间设置为过去的时间（expires）
2） 将系统时间设置为当前时间往前一点时间
```

### **什么是事件冒泡，什么是事件捕获**

```
事件冒泡指事件从发生的目标开始，沿着文档逐层向上冒泡，到documnent为止，事件捕获则相反，从documnet开始，沿着文档向下，直到目标事件为止
```

## **如何阻止事件冒泡和事件捕获**

```
IE下设置e.cancelBubble = true，在符合w3c的浏览器设置e.stopProgation()阻止事件冒泡，也可以通过preventDefault阻止默认行为，因为事件处理的默认行为就是冒泡或者通过return false

使用stopImmediatePropagation() 阻止事件捕获，需要注意的是stopImmediatePropagation() 也能阻止事件冒泡，调用后，不仅父类元素冒泡被阻止，同时该元素绑定的同类事件也会执行
```

### js实现数组去重

```  javascript
1.es6实现
function deRep( arr ) {
    return [...new Set(arr)];
}

2.遍历数组
function deRep (arr) {
    var a = [];
    for(let i = 0; i< arr.length;i++) {
        if(a.indexOf(arr[i]) === -1) {
            a.push(arr[i]);
        }
    }
    return a;
}

3.优化数组遍历，（双层循环）
function deRep(arr) {
    var a = [];
    for (let i = 0; i < arr.length; i++) {
        for(let j = i+1; j < arr.length; j++ ) {
            if(arr[i] === arr[j]) {
                ++i;
            }
        }
       a.push(arr[i]);
    }
    return a;
}

4.排序后相邻去重
function deRep(arr) {
    var a = [arr[0]];
    arr.sort();
    for(let i = 0; i < arr.length; i++ ) {
        if(arr[i] !== a[a.length - 1]) {
            a.push(arr[i]);
        }
    }
    return a;
}

5.利用map的key值不能重复
 function deReq(arr) {
     let map = new Map();
     let a = [];
     for (let i =0 ; i< arr.length; i++) {
         if(map.has(arr[i])) {
             map.set(arr[i], true);
         } else {
             map.set(arr[i],false)
             a.push(arr[i]);
         }
     }
     return a;
 }

6.利用reduce（）方法
function deReq(arr) {
    return arr.reduce((prev,cur) => {
        prev.includes(cur) || prev.push(cur));
        return prev;
    },[]);
}
```

### 数组求和有哪些方法?

```javascript
1.使用递归
function sum(arr) {
    let len = arr.length;
    if(len === 0) {
        return 0;
    } else if(len === 1) {
        return arr[0];
    } else {
        return arr[0] + sum(arr.slice(1))
    }
}

2.forEach迭代
function sum(arr) {
    let sumArr = arr;
    let sum = 0;
    sumArr.forEach((val,index,arr) => {
        sum += val;
    },0);
     return sum;
}

3.for循环累加
function sum(arr) {
    let arr1 = arr;
    let sum = 0;
    for(let i = 0; i< arr1.length; i++) {
        sum += arr[i];
    }
    return sum;
}

4.利用reduce（）方法
function sum(arr) {
    let arr1 = arr;
    let sum = arr1.reduce((prev,cur,index,arr) => {
        return prev + cur;
    })
    return sum;
}
```

### 原生ajax请求步骤有哪些

```javascript
// 创建XMLHttpRequest对象
var ajax = new XMLHttpRequest()；
// 规定请求的类型，url及是否异步处理请求
ajax.open('GET', url,true);
// 设置发送信息至服务器时内容编码格式
ajax.setRequestHeader('Content-type', 'application/x-www-from-urlencoded');
//接受服务器响应数据
ajax.onreadystatechange = function() {
    if(ajax.readyState === 4 && ajax.status === 200 || ajax.status === 304 ) {
        
    }
}
//发送请求
ajax.send(null);
```

### js如何获取dom元素

```
通过ID获取（getElementById，只获取一个元素，没找到则为null）
通过name获取（getElementByName， 返回一个类数组，没有找到则为空数组）
通过标签名（getElementsByTagName，返回一个类数组，没有找到则为空数组）
通过类名（getElementByClassName，返回一个类数组，没找到则为空数组）
通过选择器获取一个元素（querySelector，返回值只取到第一个元素）
通过选择器获取所有元素（querySelectorAll，返回一个类数组）
```



## html/CSS

### 下面有关CSS中link和@import的区别，描述错误的是（   ）

#### A.link属于XHTML标签，而@import完全是CSS提供的一种方式

#### B.当一个页面被加载的时候，link引用的CSS会同时被加载，而@import引用的CSS会等到页面全部被下载完再被加载

#### C.link在支持CSS的浏览器上都支持而@import只在5.0以上的版本有效

#### D.当使用javascript控制dom去改变样式的时候，只能使用@import方式

```
答案：D
D.可以通过 JS 操作 DOM ，插入link标签来改变样式；由于 DOM 方法是基于文档的，无法使用@import的方式插入样式
```

### 请描述一个网页从开始请求到最终显示的完整过程

```
一个网页从请求到最终显示的完整过程一般可以分为如下7个步骤：
（1）在浏览器中输入网址；
（2）发送至DNS服务器并获得域名对应的WEB服务器IP地址；
（3）与WEB服务器建立TCP连接；
（4）浏览器向WEB服务器的IP地址发送相应的HTTP请求；
（5）WEB服务器响应请求并返回指定URL的数据，或错误信息，如果设定重定向，则重定向到新的URL地址；
（6）浏览器下载数据后解析HTML源文件，解析的过程中实现对页面的排版，解析完成后在浏览器中显示基础页面；
（7）分析页面中的超链接并显示在当前页面，重复以上过程直至无超链接需要发送，完成全部数据显示。
```

### 请描述一下 cookies，sessionStorage 和 localStorage 的区别

```
请描述一下 cookies，sessionStorage 和 localStorage 的区别？
Web Storage有两种形式：LocalStorage（本地存储）和sessionStorage（会话存储）。这两种方式都允许开发者使用js设置的键值对进行操作，在在重新加载不同的页面的时候读出它们。这一点与cookie类似。
（1）与cookie不同的是：Web Storage数据完全存储在客户端，不需要通过浏览器的请求将数据传给服务器，因此x相比cookie来说能够存储更多的数据，大概5M左右。
（2）LocalStorage和sessionStorage功能上是一样的，但是存储持久时间不一样。
LocalStorage：浏览器关闭了数据仍然可以保存下来，并可用于所有同源（相同的域名、协议和端口）窗口（或标签页）；
sessionStorage：数据存储在窗口对象中，窗口关闭后对应的窗口对象消失，存储的数据也会丢失。
注意：sessionStorage 都可以用localStorage 来代替，但需要记住的是，在窗口或者标签页关闭时，使用sessionStorage 存储的数据会丢失。
（3）使用 local storage和session storage主要通过在js中操作这两个对象来实现，分别为window.localStorage和window.sessionStorage. 这两个对象均是Storage类的两个实例，自然也具有Storage类的属性和方法。
```

### 网页验证码是干什么用的？是为了解决什么安全问题

```
可以防止：恶意破解密码、刷票、论坛灌水，有效防止某个黑客对某一个特定注册用户用特定程序暴力破解方式进行不断的登陆尝试，实际上用验证码是现在很多网站通行的方式，我们利用比较简易的方式实现了这个功能。这个问题可以由计算机生成并评判，但是必须只有人类才能解答。由于计算机无法解答CAPTCHA的问题，所以回答出问题的用户就可以被认为是人类。
```

### 请你介绍一下双边距重叠触发的条件是什么？折叠的结果是什么？

```
同一个BFC（块级格式化上下文）内部，相邻的两个盒子上下外边距（margin）会发生重叠。重叠之后的结果是这两个盒子相邻部分的垂直外边距取两者中较大的那个数值。
```

### 请问单行文本与多行元素如何出现文本省略号？

```
链接：https://www.nowcoder.com/questionTerminal/3ec63840d75b49d380390aa28dc4b308?orderByHotValue=1&questionTypes=000010&mutiTagIds=574&page=1&onlyReference=false
来源：牛客网

单行文本的溢出溢出省略号使用text-overflow：ellipsis
overflow:hidden;
text-overflow:ellipsis;
white-space: nowrap;
多行文本的溢出显示省略号
display：-webkit-box
-webkit-box-orient：vertical
webkit-line-clamp： 3
overfolow-hidden；
```

### 请你谈一下transition和animation的区别

```
transition是过度属性，强调过度，他的实现需要触发一个事件（比如鼠标移动上去，焦点，点击等）才执行动画。它类似于flash的补间动画，设置一个开始关键帧，一个结束关键帧。

animation是动画属性，他的实现不需要触发事件，设定好时间之后可以自己执行，且可以循环一个动画。他也类似于flash的补间动画，但是他可以设置多个关键帧（用@keyframe定义）完成动画。
```

### 当块级元素设置 box-sizing:border-box 属性时，该块级元素的 width 包含哪几个部分

```
padding,border和content
```

### a的输出结果是__

```
var a=[1,2,3,4,5];
a.splice(1,3,5,2,1);
console.log(a);
```

```
答案：输出为[ 1, 5, 2, 1, 5 ]
splice() 方法向/从数组中添加/删除项目，然后返回被删除的项目。
splic(1,3)，删除了，从第二位开始，3个字符的数量，返回[1,5]，
数组[5,2,1]，添加到删除的位置，返回的数组就是[1,5,2,1,5]
```

### 给出伪元素(::before, ::after)的几种使用场景？

```
1.清除浮动时
2.利用attr()来实现某些动态功能时
3.与counter()结合实现序号问题，而不用使用列表元素
4.实现各种特效
```

### 对BFC规范的理解？

```
形成BFC:1.float的值不为none。
                2.overflow的值不为visible。
                3.display的值为table-cell, table-caption, inline-block中的任何一个。
                4.position的值不为relative和static。
BFC的规则:
BFC中的元素的布局是不受外界的影响（我们往往利用这个特性来消除浮动元素对其非浮动的兄弟元素和其子元素带来的影响。）并且在一个BFC中，块盒与行盒（行盒由一行中所有的内联元素所组成）都会垂直的沿着其父元素的边框排列。
```

### 常用的伪类选择器有哪些？(至少写出4个)

```
结构为类选择器：        -type  nth-of-type      -child  nth-child      
其他：:root  :not    :empty   :target
状态伪类选择器：      :focus    :checked    ::selection    :enable   :disabled   :read-only  :before  :after
```

### Doctype作用? 严格模式与混杂模式如何区分？它们有何意义?

```
doctype告诉浏览器以什么模式渲染文档

严格模式 以浏览器支持的的最高版本渲染文档

混杂模式 从低版本到高版本渲染
```

### HTML与XHTML——二者有什么区别

```
1、XHTML 元素必须被正确地嵌套。
错误：<p><span>this is example.</p></span>
正确：<p><span>this is example.</span></p>
而html不需要被正确嵌套也不会报错。
2、 XHTML 元素必须被关闭。即使是空标签</br>
html可以写成<br>
3、 XHTML 标签名必须用小写字母。html可以大写。
4、 XHTML 文档必须拥有根元素。
5、 所有的 XHTML 元素必须被嵌套于 <html> 根元素中。
而html不是必须的。
```

### position的absolute与fixed共同点与不同点

```
共同点：
1.改变行内元素的呈现方式，display被置为inline-block；
2.让元素脱离普通流，不占据空间；
3.默认会覆盖到非定位元素上

不同点：
absolute的”根元素“是可以设置的，而fixed的”根元素“固定为浏览器窗口。
当你滚动网页，fixed元素与浏览器窗口之间的距离是不变的。
```

### px和em的区别

```
px表示像素 (计算机屏幕上的一个点：1px = 1/96in)，是绝对单位，不会因为其他元素的尺寸变化而变化;
em表示相对于父元素的字体大小。em是相对单位 ，没有一个固定的度量值，而是由其他元素尺寸来决定的相对值;
```

### 请简要描述margin重合问题，及解决方式

```
1.同向margin的重叠：
1图片的margin-top与3图片的margin-top发生重叠，2图片的margin-bottom与3图片的margin-bottom发生重叠。这时候重叠之后的margin值由发生重叠两片的最大值决定；如果其中一个出现负值，则由最大的正边距减去绝对值最大的负边距，如果没有最大正边距，则由0减去绝对值最大的负边距。
解决同向重叠的方法：
（1）在最外层的div中加入overflow:hidden;zoom:1
（2）在最外层加入padding:1px;属性
（3）在最外层加入：border:1px solid #cacbcc;
2.异向重叠问题：
1图片的margin-bottom与2图片的margin-top发生重叠，这时候重叠之后的margin值由发生重叠两图片的最大值的决定的。
解决异向重叠问题：
float:left（只能解决IE6浏览器中的异向重叠问题，可以解决IE8以上、chorme、firefox、opera下的同向重叠问题）
```

### 浏览器的内核分别是什么

```
IE: trident内核

Firefox：gecko内核

Safari：webkit内核

Opera：以前是presto内核，Opera现已改用Google Chrome的Blink内核

Chrome：Blink(基于webkit，Google与Opera Software共同开发)
```

### $(document).ready()方法和window.onload有什么区别

```
window.onload方法是在网页中所有的元素(包括元素的所有关联文件)完全加载到浏览器后才执行的。

$(document).ready() 方法可以在DOM载入就绪时就对其进行操纵，并调用执行绑定的函数。
```

### 介绍一下标准的CSS的盒子模型？与低版本IE的盒子模型有什么不同的？

```
标准的盒模型是基于 doctype 正确书写的情况下，并且是高于 IE6 的浏览器才会有的。

标准盒子模型：宽度=内容的宽度（content）+ border + padding + margin

低版本IE盒子模型：宽度=内容宽度（content+border+padding）+ margin
```

### display:none和visibility:hidden的区别

```
visibility:hidden隐藏，但在浏览时保留位置
display:none视为不存在，且不加载
```

### 浮动元素引起的问题

```
a. 父元素的高度无法被撑开，影响与父元素同级的元素
b. 与浮动元素同级的非浮动元素会跟随其后
c. 若非第一个元素浮动，则该元素之前的元素也需要浮动，否则会影响页面显示的结构
```

### **前端页面有哪三层构成，分别是什么，作用是什么**

```
结构层HTML，表示层CSS，行为层JS

网页的结构层（structural layer）由 HTML 或 XHTML 之类的标记语言负责创建。标签，也就是那些出现在尖括号里的单词，对网页内容的语义含义做出了描述，但这些标签不包含任何关于如何显示有关内容的信息。例如，P 标签表达了这样一种语义：“这是一个文本段。”

网页的表示层（presentation layer） 由 CSS 负责创建。 CSS 对“如何显示有关内容”的问题做出了回答。

网页的行为层（behavior layer）负责回答“内容应该如何对事件做出反应”这一问题。这是 Javascript 语言和 DOM 主宰的领域。
```

### **HTML5应用程序缓存为应用带来什么优势**

```
应用程序缓存为应用带来三个优势：

1）离线浏览：用户可在应用离线时使用它们。

2）速度：已缓存资源加载得更快。

3）减少服务器负载：浏览器将只从服务器下载更新过或更改过的资源。
```

### **谈谈对响应式布局的看法**

```
响应式布局有缺点也有优点。
优点：面对不同分辨率设备，灵活性强，能够快捷地解决设备显示适应问题。
缺点：兼容各种设备时所需工作量大、效率低下、代码累赘，会隐藏无用的元素，加载时间延长，其实这是一种折中性质的十设计解决方案，由于多方面元素影响而达不到最佳效果，在一定程度上改变了网站原有的布局结构，会出现用户混淆的情况。
```

### **请写出至少5个html5新增的标签，并说明其语义和应用场景**

```
section：定义文档中的一个章节

nav：定义只包含导航链接的章节

header：定义页面或章节的头部。它经常包含 logo、页面标题和导航性的目录。

footer：定义页面或章节的尾部。它经常包含版权信息、法律信息链接和反馈建议用的地址。

aside：定义和页面内容关联度较低的内容——如果被删除，剩下的内容仍然很合理。
```

### **简述一下src与href的区别**

```
src用于替换当前元素；href用于在当前文档和引用资源之间确立联系。

src是source的缩写，指向外部资源的位置，指向的内容将会嵌入到文档中当前标签所在位置

href是Hypertext Reference的缩写，指向网络资源所在位置，建立和当前元素（锚点）或当前文档（链接）之间的链接
```

### **CSS3有哪些新特性？**

```
CSS3实现圆角（border-radius），阴影（box-shadow），对文字加特效（text-shadow），线性渐变（gradient），变形（transform）

增加了更多的CSS选择器 多背景 rgba，在CSS3中唯一引入的伪元素是::selection，媒体查询，多栏布局
```

### **line-height三种赋值方式有何区别？（带单位、纯数字、百分比）**

```
带单位：px不用计算，em则会使元素以其父元素font-size值为参考来计算自己的行高
纯数字：把比例传递给后代，例如父级行高为1.5，子元素字体为18px，则子元素行高为1.5*18=27px
百分比：将计算后的值传递给后代
```

### **css属性content有什么作用？有什么应用？**

```
css的content属性专门应用在 before/after 伪元素上，用于来插入生成内容。
可以配合自定义字体显示特殊符号。
```

### **介绍以下你对浏览器内核的理解？**

```
1、主要分成两部分：渲染引擎（layout engineer或Rendering Engine）和JS引擎。

2、渲染引擎：负责取得网页的内容（HTML、XML、图像等等）、整理讯息（例如加入CSS等）、以及计算网页的显示方式、然后会输出至显示器或打印机。浏览器的内核的不同对于网页的语法解释会有不同、所以渲染的效果也不相同。所有网页浏览器、电子邮件客户端以及其他需要编辑、显示网络内容的应用程序都需要内核

3、JS引擎则：解析和执行javascript来实现网页的动态效果。

4、最开始渲染引擎和JS引擎并没有区分得很明确，后来JS引擎越来越独立，内核九倾向于只指渲染引擎。
```

### **选择器优先级是怎样的？**

```
1、！important>行内样式>id选择器>类选择器>标签选择器>通配符>继承

2、权重算法：(0,0,0,0)==》第一个0对应的是important的个数，第二个0对应的是id选择器的个数，第三个0对应的类选择器的个数，第四个0对应的是标签选择器的个数，就是当前选择器的权重

3、比较：先从第一个0开始比较，如果第一个0大，那么说明这个选择器的权重高，如果第一个相同，比较第二个，依次类推。
```

### **CSS3有哪些新特性**

```
实现圆角border-radius，阴影box-shadow，边框图片border-image
对文字加特效text-shadow，强制文本换行word-wrap，线性渐变linear-gradient
实现旋转transform:rotate(90deg),缩放scale(0.85,0.90),translate(0px,-30px)定位,倾斜skew(-9deg,0deg);
增加了更多的CSS选择器、多背景、rgba()
唯一引入的伪元素是::selection；
实现媒体查询@media，多栏布局flex
过渡transition 动画animation
```

### **::before 和 :after中双冒号和单冒号有什么区别？解释一下这2个伪元素的作用**

```
单冒号(:)用于CSS3伪类，双冒号(::)用于CSS3伪元素。（伪元素由双冒号和伪元素名称组成）,双冒号是在当前规范中引入的，用于区分伪类和伪元素
```

### **block、inline和inline-block的区别**

```
display：block
block元素又叫做块级元素，它独占一行，多个block元素各占一行。默认情况下block元素 宽度自动填满父元素宽度
可以设置weight和width属性，块级元素设置了width还是独占一行
可以设置padding和margin属性
display：inline
    1.inline元素又叫内联元素，不会占一行，多个内联元素会排列在一行，一行排列不下去才会 行，，宽度随元素的内容变化
    2.设置width和weight属性无效
    3.inline元素的margin和padding属性，水平方向上都能产生边距效果，竖直方向上不会产生 效果
    display： inline-block
内联块级元素拥有inline元素的多个占据同行特性和block元素的设置高度宽度特性和设置 padding和margin特性
```

### **display：none和visiblity：hidden的区别**

```
为none的时候不占空间，为hidden的时候隐藏元素依然占据空间

为none的会产生回流和重绘，visiblity：hidden的时候只产生重绘

visiblity：hidden的子孙元素设置visiblity：hidden时会失效
```

### css选择器有哪些

```
选择器有id选择器、元素选择器、属性选择器、类选择器、后代选择器、子元素选择器、相邻兄弟选择器、伪类和伪元素。
```

### 清楚浮动的方法？

```
1.父级div定义 height
原理：父级div手动定义height，就解决了父级div无法自动获取到高度的问题。

2，结尾处加空div标签 clear:both
原理：添加一个空div，利用css提高的clear:both清除浮动，让父级div能自动获取到高度
优点：简单、代码少、浏览器支持好、不容易出现怪问题

3，父级div定义 伪类:after 和 zoom
原理：IE8以上和非IE浏览器才支持:after，原理和方法2有点类似，zoom(IE转有属性)可解决ie6,ie7浮动问题

4，父级div定义 overflow:hidden
原理：必须定义width或zoom:1，同时不能定义height，使用overflow:hidden时，浏览器会自动检查浮动区域的高度
```



## Vue

### react和vue有哪些不同，说说你对这两个框架的看法

```
相同点

· 都支持服务器端渲染

· 都有Virtual DOM,组件化开发,通过props参数进行父子组件数据的传递,都实现webComponent规范

· 数据驱动视图

· 都有支持native的方案,React的React native,Vue的weex

不同点

· React严格上只针对MVC的view层,Vue则是MVVM模式

· virtual DOM不一样,vue会跟踪每一个组件的依赖关系,不需要重新渲染整个组件树.而对于React而言,每当应用的状态被改变时,全部组件都会重新渲染,所以react中会需要shouldComponentUpdate这个生命周期函数方法来进行控制

· 组件写法不一样, React推荐的做法是 JSX + inline style, 也就是把HTML和CSS全都写进JavaScript了,即'all in js'; Vue推荐的做法是webpack+vue-loader的单文件组件格式,即html,css,jd写在同一个文件;

· 数据绑定: vue实现了数据的双向绑定,react数据流动是单向的

· state对象在react应用中不可变的,需要使用setState方法更新状态;在vue中,state对象不是必须的,数据由data属性在vue对象中管理
```

### v-if和v-show的共同点和区别

```
v-if 和 v-show 都是动态显示DOM元素。

区别：
编译过程：
v-if 是 真正 的 条件渲染，因为它会确保在切换过程中条件块内的事件监听器和子组件适当地被销毁和重建。v-show
的元素始终会被渲染并保留在 DOM 中。v-show 只是简单地切换元素的 CSS 属性display。

编译条件：
v-if 是惰性的：如果在初始渲染时条件为假，则什么也不做。直到条件第一次变为真时，才会开始渲染条件块。v-show不管初始条件是什么，元素总是会被渲染，并且只是简单地基于
CSS 进行切换。

性能消耗：
v-if有更高的切换消耗。v-show有更高的初始渲染消耗。
应用场景：
v-if适合运行时条件很少改变时使用。v-show适合频繁切换。
```

### 简述Vue的响应式原理

```
当一个Vue实例创建时，vue会遍历data选项的属性，用 Object.defineProperty 将它们转为 getter/setter并且在内部追踪相关依赖，在属性被访问和修改时通知变化。
每个组件实例都有相应的 watcher 程序实例，它会在组件渲染的过程中把属性记录为依赖，之后当依赖项的 setter 被调用时，会通知 watcher 重新计算，从而致使它关联的组件得以更新。
```

### vue中 key 值的作用？

```
当 Vue.js 用 v-for 正在更新已渲染过的元素列表时，它默认用“就地复用”策略。如果数据项的顺序被改变，Vue 将不会移动 DOM 元素来匹配数据项的顺序， 而是简单复用此处每个元素，并且确保它在特定索引下显示已被渲染过的每个元素。key的作用主要是为了高效的更新虚拟DOM。
```

### **vue等单页面应用及其优缺点**

```
优点：Vue 的目标是通过尽可能简单的 API 实现响应的数据绑定和组合的视图组件，核心是一个响应的数据绑定系统。MVVM、数据驱动、组件化、轻量、简洁、高效、快速、模块友好。
缺点：不支持低版本的浏览器，最低只支持到IE9；不利于SEO的优化（如果要支持SEO，建议通过服务端来进行渲染组件）；第一次加载首页耗时相对长一些；不可以使用浏览器的导航按钮需要自行实现前进、后退。
```

### **怎么定义 vue-router 的动态路由? 怎么获取传过来的值**

```
在 router 目录下的 index.js 文件中，对 path 属性加上 /:id，使用 router 对象的 params.id 获取。
```

### <keep-alive></keep-alive>的作用是什么?

```
<keep-alive></keep-alive> 包裹动态组件时，会缓存不活动的组件实例,主要用于保留组件状态或避免重新渲染。
```

### 指令`v-el`的作用是什么?

```
提供一个在页面上已存在的 DOM 元素作为 Vue 实例的挂载目标.可以是 CSS 选择器，也可以是一个 HTMLElement 实例
```

### scss是什么？在vue.cli中的安装使用步骤是？有哪几大特性？

```
css的预编译。

使用步骤：
第一步：用npm 下三个loader（sass-loader、css-loader、node-sass）
第二步：在build目录找到webpack.base.config.js，在那个extends属性中加一个拓展.scss
第三步：还是在同一个文件，配置一个module属性
第四步：然后在组件的style标签加上lang属性 ，例如：lang=”scss”

有哪几大特性:
1、可以用变量，例如（$变量名称=值）；
2、可以用混合器
3、可以嵌套
```

### **聊聊你对Vue.js的template编译的理解？**

```
首先，通过compile编译器把template编译成AST语法树（abstract syntax tree 即 源代码的抽象语法结构的树状表现形式），compile是createCompiler的返回值，createCompiler是用以创建编译器的。另外compile还负责合并option。
然后，AST会经过generate（将AST语法树转化成render funtion字符串的过程）得到render函数，render的返回值是VNode，VNode是Vue的虚拟DOM节点，里面有（标签名、子节点、文本等等）
```

### methods、computed、watch三者的区别

```
methods是个方法，执行的时候需要事件进行触发
computed是一个计算属性，是实时响应的，只要data中的属性发生了变化那么就会触发computed，计算属 性是基于属性的依赖进行缓存的，methods调用的时候需要加()，而computed调用的时候是不需要加()
watch属性监听，watch用来监听属性的变化，当值发生变化的时候来执行特定的函数，watch监听属性的时候 会有2个参数newVal和oldVal一个新值一个旧值
```

### vue中组件创建的方式有哪些？

```
全局组件和局部组件
全局组件 Vue.component();参数1：组件名称  参数2：组件的配置项
局部组件 new Vue({    components:{} key值为组件名称  val值为组件的配置项 })
```

### vue中的过滤器如何使用

```
Vue.filter()
参数1：过滤器名称
参数2：过滤器实现的方法  该方法中有2个参数  参数1为需要过滤的数据，参数2为过滤器传递的参数
```

### 请解释一下vue的中单向数据流的理解

```
数据从父级组件传递给子组件,只能单向绑定，子组件不能直接修改从父级传递过来的数据
数据只能从一个方向来修改状态,如果父组件给N个子组件进行了数据传递。那么某一个子组件中修改了这个数 据，那么就会导致其他组件的数据也会发生改变。因此数据只能从一个方向来修改状态
```

### 为什么在组件内部data是一个函数而不是一个对象?

```
因为每次调用组件的时候都会重新生成一个对象,如果是一个对象的情况下，data数据会进行复用(因为对象是引 用数据类型),而当data是一个函数的时候每次调用的时候就会返回一个新的对象
```

### 什么是路由守卫？路由的钩子函数有哪些？分别说出使用的场景，及用法

```
1、什么是路由守卫？路由跳转前后做的一些验证
2、路由常见的钩子函数 berforeRouteEnter、beforeRouteUpdate、beforeRouteLeave
使用的场景 beforeRouteEnter:当路由进入之前:登陆验证、热力图的记录、
beforeRouteUpdate:当路由进行更新的时候。如果当前路由发生了变化，但是不需要组件的创建销毁的过程的 时候，就需要用到这个钩子函数
beforeRouterLeave:当路由离开的时候、当用户没有进行支付离开的时候、当用户填写完信息没有保存的时候等
```



## 项目/业务

### 如何避免弹框中的表格在点击修改赋值后，无法清空表单值的问题？

```
使用setTimeout、nextTick之类的异步方法来进行表单赋值
```

### 如何避免自己写的css样式影响他人？

```
将自己页面中的css样式都定义在一个总的父级之下
```

### 如何精确地比较金额的大小

```
应该使用util里的floatEqual方法
```

### 根据按钮命名规范,批量操作、逆向操作、再次操作、连续操作、独立功能模块功能的按钮分别应该以怎样的格式命名？

```
批量操作，以btn-bat-开头，加上英文简称。
逆向操作，以btn-un-开头，加上英文简称。
再次操作，以btn-re-开头，加上英文简称。
连续操作，以btn-con-开头，加上英文简称。
独立功能模块，如工作流，可以加上前缀btn-wf- 。
```

### 文件夹的命名是否应该用驼峰命名法？

```
否，应该使用小写英文加‘-’的格式命名，例如：my-script.js
```

### JS变量是否应该使用双引号？

```
否，应该使用单引号
```

### 暂时没用代码应该怎样处理？

```
不要的代码，应该及时删除，如果以后需要，需要打上TODO
```

### 箭头函数是否应该多使用？

```
是，应多使⽤箭头函数，避免函数中this指向问题，尽量使⽤原⽣API
```

### v-for在使用的时候应该注意什么问题？

```
必须加key，且key必须具有唯⼀性
```

### v-for与v-if同时使用正确吗？

```
不正确，应该避免v-for与v-if同时使⽤
```

### 为什么要避免使用mixin、继承、依赖注⼊？

```
使⽤mixix，继承，依赖注⼊，会导致代码可读性差，逻辑不清晰，且组件依赖性⾼，⽆法解耦。应该
避免使⽤。
如果有相同的业务逻辑，应该将公共的⽅法提取出来！
```

### 为Element-ui设置表格高度时，是否应该给一个固定值？

```
不应该，应该设置动态⾼度（innerHeight）
```

### 第三方库的使用应该重点注意哪一点？

```
在项⽬中使⽤第三⽅库的时候，例如（handsontable、Sortable、Viewer）应注意销毁实例，避免内
存泄漏问题
```

### Element-ui，el-table组件row-key属性应该什么时候设置？

```
表格使⽤拖拽 、表格内的表单校验、应该设置row-key属性.
```

### this.$set()的使用场景？

```
在给声明的数据对象添加属性，动态操作数组时，应该使⽤this.$set，具体参考Vue官⽹API
```

### 书写代码时，应该注意哪些问题？

```
代码写好注释，包括⻚⾯结构注释，JS⽅法避免过⻓的⽅法体，特别是复杂的业务，同时代码应该做好格式化！
```

### 复制属性应该使用util里的哪个方法?

```
copyProperties(target, source)方法
```

### 下载文件应该使用util里的哪个方法？

```
download(url[,fileName])方法
```

### 生成UUID应该使用util里的哪个方法？

```
generateUUID()方法
```

### 人名币大写转换应该使用哪个公共方法？

```
filter.js里的formatRMB(value)
```

### 千分位转换应该使用哪个公共方法？

```
filter.js里的formatCurrency(value, decimals, decPoint, thousandsSep, roundtag)
```

### 时间日期格式化应该使用哪个公共方法？

```
filter.js里的formatDate(value[, valueFormat])
```





